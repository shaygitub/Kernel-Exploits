#include "utils.h"


int CharpToWcharp(const char* ConvertString, WCHAR* ConvertedString) {
    int WideNameLen = MultiByteToWideChar(CP_UTF8, 0, ConvertString, -1, NULL, 0);
    MultiByteToWideChar(CP_UTF8, 0, ConvertString, -1, ConvertedString, WideNameLen);
    return WideNameLen;
}


int WcharpToCharp(char* ConvertedString, const WCHAR* ConvertString) {
    int MultiByteLen = WideCharToMultiByte(CP_UTF8, 0, ConvertString, -1, NULL, 0, NULL, NULL);
    WideCharToMultiByte(CP_UTF8, 0, ConvertString, -1, ConvertedString, MultiByteLen, NULL, NULL);
    return MultiByteLen;
}


BOOL CheckLetterInString(char Letter, char* String) {
    for (int i = 0; i < strlen(String); i++) {
        if (String[i] == Letter) {
            return TRUE;
        }
    }
    return FALSE;
}


CUSTOM_RETURN IsValidDriverFile(WIN32_FIND_DATAA* FileData, const char* RequiredSubdir, const char* FileName, const char* RootPath) {
    char* ActualName = FileData->cFileName;
    if (strcmp(ActualName, FileName) != 0) {
        // printf("File %s != Expected File %s!\n", ActualName, FileName);
        return BAD;  // Cannot print name of ANY file that does not have the same name - will spam the console
    }

    char ActualExtension[5];
    memcpy(ActualExtension,(PVOID)((ULONG64)ActualName + strlen(ActualName) - 4), 5);
    if (!((FileData->dwFileAttributes & FILE_ATTRIBUTE_SYSTEM) || strcmp(ActualExtension, ".sys") == 0)) {
        printf("[-] File %s is not a system file (.sys), actual extension = %s!\n", ActualName, ActualExtension);
        return BAD;
    }

    if (FileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        printf("[!] File %s is a directory, for later iterate on it too!\n", ActualName);
        return BAD;
    }

    if (RequiredSubdir == NULL) {
        printf("[+] Found file %s (NO REQUIRED SUBDIR)!\n", (char*)FileData->cFileName);
        return GOOD;
    }
    
    char SubDir[MAX_PATH];
    DWORD SubDirInd = 0;
    DWORD RootInd = (DWORD)strlen(RootPath) - 5;
    while (RootPath[RootInd] != '\\' || RootInd == 0) {
        RootInd--;
    }
    if (RootInd != 0) {
        RootInd++;
    }
    while (RootPath[RootInd] != '\\') {
        SubDir[SubDirInd] = RootPath[RootInd];
        RootInd++;
        SubDirInd++;
    }
    SubDir[SubDirInd] = '\0';
    if (strcmp(SubDir, RequiredSubdir) != 0) {
        printf("[-] File %s subdir %s != expected %s\n", ActualName, SubDir, RequiredSubdir);
        return BAD_SPECIAL;
    }
    
    printf("[+] Found file %s with the correct subdirectory (%s)!\n", ActualName, SubDir);
    return GOOD;
}


BOOL FindFileInDrive(const char* DrivePath, const char* FileName, char* FullPathBuffer, const char* RequiredSubdir, char* OldFilePath, BOOL OldSaved) {
    char NextFilePath[MAX_PATH];
    char ContinueStr[5] = "\\*.*";
    BOOL MoreFiles = TRUE;
    BOOL InitialFind = FALSE;
    BOOL NextRes = FALSE;
    CUSTOM_RETURN IsValid;
    WIN32_FIND_DATAA CurrFileData = { 0 };
    if (OldFilePath == NULL) {
        InitialFind = TRUE;
        OldFilePath = (char*)malloc(MAX_PATH);
        if (OldFilePath == NULL) {
            printf("[-] Could not allocate memory for initial old file path!\n");
            return FALSE;
        }
    }
    // printf("[!] Current finding path: %s\n", DrivePath);
    HANDLE CurrFile = FindFirstFileA(DrivePath, &CurrFileData);

    if (CurrFile == INVALID_HANDLE_VALUE){
        //if (RequiredSubdir == NULL) {
        //    printf("[-] Could not find any file in the DrivePath of %s (NO REQUIRED SUBDIR) - %d!\n", DrivePath, GetLastError());
        //}
        //else {
        //    printf("[-] Could not find any file in the DrivePath of %s and the subdirectory %s - %d!\n", DrivePath, RequiredSubdir, GetLastError());
        //}
        return FALSE;
    }
    
    while (MoreFiles) {
        if (strcmp(CurrFileData.cFileName, ".") != 0 && strcmp(CurrFileData.cFileName, "..") != 0) {
            IsValid = IsValidDriverFile(&CurrFileData, RequiredSubdir, FileName, DrivePath);
            if (IsValid == GOOD) {
                memcpy(FullPathBuffer, DrivePath, strlen(DrivePath) - 3);
                memcpy((PVOID)((ULONG64)FullPathBuffer + strlen(DrivePath) - 3), CurrFileData.cFileName, strlen(CurrFileData.cFileName) + 1);
                return TRUE;
            }
            else if (IsValid == BAD_SPECIAL) {
                if (OldSaved) {
                    RtlZeroMemory(OldFilePath, MAX_PATH);
                }
                memcpy(OldFilePath, DrivePath, strlen(DrivePath) - 3);
                memcpy((PVOID)((ULONG64)OldFilePath + strlen(DrivePath) - 3), CurrFileData.cFileName, strlen(CurrFileData.cFileName) + 1);
                OldSaved = TRUE;
            }
            else {
                if ((CurrFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && CurrFileData.cFileName[0] != '.' && CurrFileData.cFileName[0] != '$') {
                    memcpy(NextFilePath, DrivePath, strlen(DrivePath) - 3);
                    memcpy((PVOID)((ULONG64)NextFilePath + strlen(DrivePath) - 3), CurrFileData.cFileName, strlen(CurrFileData.cFileName));
                    memcpy((PVOID)((ULONG64)NextFilePath + strlen(DrivePath) + strlen(CurrFileData.cFileName) - 3), ContinueStr, strlen(ContinueStr) + 1);
                    NextRes = FindFileInDrive(NextFilePath, FileName, FullPathBuffer, RequiredSubdir, OldFilePath, OldSaved);
                    if (NextRes) {
                        return TRUE;
                    }
                }
            }
        }
        MoreFiles = FindNextFileA(CurrFile, &CurrFileData);
    }
    

    // Copy old path (not with requested subdirectory) into path buffer if any SUBDIR was requested -
    if (OldSaved && InitialFind) {
        printf("[+] Found a file instance of %s not with requested subdir but with subdir %s (no other instance)!\n", FileName, OldFilePath);
        memcpy(FullPathBuffer, OldFilePath, MAX_PATH);  // Because OldFilePath's remainder is always zeroed out - will also zero out FullPathBuffer
        return TRUE;
    }
    return FALSE;
}